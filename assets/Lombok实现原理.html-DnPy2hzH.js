import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as c,o as a}from"./app-DwgEqN4h.js";const d={};function n(i,e){return a(),t("div",null,e[0]||(e[0]=[c('<blockquote><p>转自 <a href="https://www.cnblogs.com/jing99/p/13785684.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/jing99/p/13785684.html</a></p></blockquote><h1 id="lombok实现原理" tabindex="-1"><a class="header-anchor" href="#lombok实现原理"><span>Lombok实现原理</span></a></h1><p><code>Lombok</code>使用的过程中，只需要添加相应的注解，无需再为此写任何代码。但是自动生成的代码到底是如何产生的呢？</p><p><strong>核心之处就是对于注解的解析上</strong>。<code>JDK5</code>引入了注解的同时，也提供了两种解析方式。</p><h2 id="运行时解析" tabindex="-1"><a class="header-anchor" href="#运行时解析"><span>运行时解析：</span></a></h2><p>运行时能够解析的注解，必须将<code>@Retention</code>设置为<code>RUNTIME</code>，这样就可以通过反射拿到该注解。<code>java.lang.reflect</code>反射包中提供了一个接口<code>AnnotatedElement</code>，该接口定义了获取注解信息的几个方法，<code>Class</code>、<code>Constructor</code>、<code>Field</code>、<code>Method</code>、<code>Package</code>等都实现了该接口，对反射熟悉的朋友应该都会很熟悉这种解析方式。</p><h2 id="编译时解析" tabindex="-1"><a class="header-anchor" href="#编译时解析"><span>编译时解析</span></a></h2><p>编译时解析有两种机制，分别简单描述下：</p><ul><li><p><code>Annotation Processing Tool</code>：<code>apt</code>自<code>JDK5</code>产生，<code>JDK7</code>已标记为过期，不推荐使用，<code>JDK8</code>中已彻底删除，自<code>JDK6</code>开始，可以使用<code>Pluggable Annotation Processing API</code>来替换它，apt被替换主要有2点原因：<code>api</code>都在<code>com.sun.mirror</code>非标准包下；没有集成到<code>javac</code>中，需要额外运行。</p></li><li><p><code>Pluggable Annotation Processing API</code>：**<code>JSR 269</code>**自<code>JDK6</code>加入，作为<code>apt</code>的替代方案，它解决了<code>apt</code>的两个问题，<code>javac</code>在执行的时候会调用实现了该<code>API</code>的程序，这样我们就可以对编译器做一些增强，这时<code>javac</code>执行的过程如下：</p></li></ul><figure><img src="https://winkik.github.io/picx-images-hosting/image.92q6vlm33l.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><code>Lombok</code>本质上就是一个实现了<a href="https://www.jcp.org/en/jsr/detail?id=269" target="_blank" rel="noopener noreferrer"><code>JSR 269 API</code></a>的程序。在使用<code>javac</code>的过程中，它产生作用的具体流程如下：</p><ul><li><code>javac</code>对源代码进行分析，生成了一棵抽象语法树（<code>AST</code>）</li><li>运行过程中调用实现了<code>JSR 269 API</code>的<code>Lombok</code>程序</li><li>此时<code>Lombok</code>就对第一步骤得到的<code>AST</code>进行处理，找到@Data注解所在类对应的语法树（<code>AST</code>），然后修改该语法树（<code>AST</code>），增加<code>getter</code>和<code>setter</code>方法定义的相应树节点</li><li><code>javac</code>使用修改后的抽象语法树（<code>AST</code>）生成字节码文件，即给class增加新的节点（代码块）</li></ul><p>拜读了<code>Lombok</code>源码，对应注解的实现都在<code>HandleXXX</code>中，比如<code>@Getter</code>注解的实现是<code>HandleGetter.handle()</code>。还有一些其它类库使用这种方式实现，比如<a href="https://github.com/google/auto" target="_blank" rel="noopener noreferrer">Google Auto</a>、<a href="http://square.github.io/dagger/" target="_blank" rel="noopener noreferrer">Dagger</a>等等。</p>',13)]))}const p=o(d,[["render",n],["__file","Lombok实现原理.html.vue"]]),m=JSON.parse('{"path":"/posts/backend/java/Lombok%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html","title":"Lombok实现原理","lang":"zh-CN","frontmatter":{"title":"Lombok实现原理","date":"2024-12-15T00:00:00.000Z","article":true,"description":"转自 https://www.cnblogs.com/jing99/p/13785684.html Lombok实现原理 Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。但是自动生成的代码到底是如何产生的呢？ 核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。 运行时解析： 运行时能够解析的注解，必须将...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/backend/java/Lombok%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"winkit的博客"}],["meta",{"property":"og:title","content":"Lombok实现原理"}],["meta",{"property":"og:description","content":"转自 https://www.cnblogs.com/jing99/p/13785684.html Lombok实现原理 Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。但是自动生成的代码到底是如何产生的呢？ 核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。 运行时解析： 运行时能够解析的注解，必须将..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://winkik.github.io/picx-images-hosting/image.92q6vlm33l.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-15T13:58:00.000Z"}],["meta",{"property":"article:published_time","content":"2024-12-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-15T13:58:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Lombok实现原理\\",\\"image\\":[\\"https://winkik.github.io/picx-images-hosting/image.92q6vlm33l.webp\\"],\\"datePublished\\":\\"2024-12-15T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-15T13:58:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"winkit\\"}]}"]]},"headers":[{"level":2,"title":"运行时解析：","slug":"运行时解析","link":"#运行时解析","children":[]},{"level":2,"title":"编译时解析","slug":"编译时解析","link":"#编译时解析","children":[]}],"git":{"createdTime":1734270764000,"updatedTime":1734271080000,"contributors":[{"name":"winkit","email":"huannjie@163.com","commits":2}]},"readingTime":{"minutes":1.98,"words":595},"filePathRelative":"posts/backend/java/Lombok实现原理.md","localizedDate":"2024年12月15日","excerpt":"<blockquote>\\n<p>转自 <a href=\\"https://www.cnblogs.com/jing99/p/13785684.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.cnblogs.com/jing99/p/13785684.html</a></p>\\n</blockquote>\\n<h1>Lombok实现原理</h1>\\n<p><code>Lombok</code>使用的过程中，只需要添加相应的注解，无需再为此写任何代码。但是自动生成的代码到底是如何产生的呢？</p>\\n<p><strong>核心之处就是对于注解的解析上</strong>。<code>JDK5</code>引入了注解的同时，也提供了两种解析方式。</p>","autoDesc":true}');export{p as comp,m as data};
